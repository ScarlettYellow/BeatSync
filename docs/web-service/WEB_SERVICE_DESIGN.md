# BeatSync Web服务设计方案

## 一、需求确认

### 1.1 核心功能需求

**已明确**：
- ✅ 上传两个视频文件（dance和bgm）
- ✅ 调用后端API处理
- ✅ 下载处理结果

**需要确认**：
- ❓ 处理时间较长（几分钟到十几分钟），是否需要异步处理？
- ❓ 是否需要进度反馈？
- ❓ 用户是否需要选择处理版本（modular/V2/并行）？
- ❓ 文件大小限制？
- ❓ 是否需要处理历史记录？

### 1.2 技术选型

**后端框架**：
- **FastAPI**（推荐）：异步支持好，自动生成API文档，性能优秀
- Flask：简单易用，但异步支持较弱

**前端框架**：
- 纯HTML+JavaScript（简单场景）
- Vue.js / React（复杂交互）
- 建议：先做纯HTML版本，后续可升级

## 二、架构设计方案

### 方案A：同步处理（简单但有限制）

**流程**：
1. 用户上传文件 → 后端接收
2. 立即开始处理 → 前端等待
3. 处理完成 → 返回结果

**优点**：
- 实现简单
- 代码量少

**缺点**：
- 请求可能超时（处理时间长）
- 用户体验差（长时间等待）
- 无法处理大文件

**适用场景**：
- 仅用于测试
- 处理时间很短（<30秒）

---

### 方案B：异步处理 + 轮询（推荐）

**流程**：
1. 用户上传文件 → 后端接收，返回任务ID
2. 后端异步处理 → 前端轮询状态
3. 处理完成 → 前端获取结果

**优点**：
- 支持长时间处理
- 用户体验好（有进度反馈）
- 可扩展性强

**缺点**：
- 实现稍复杂
- 需要任务队列（可选）

**技术实现**：
- 后端：FastAPI + 后台任务
- 前端：轮询或WebSocket

---

### 方案C：异步处理 + WebSocket（最佳体验）

**流程**：
1. 用户上传文件 → 后端接收，建立WebSocket连接
2. 后端异步处理 → 实时推送进度
3. 处理完成 → 推送结果

**优点**：
- 实时进度反馈
- 用户体验最佳

**缺点**：
- 实现最复杂
- 需要WebSocket支持

---

## 三、推荐方案：方案B（异步处理 + 轮询）

### 3.1 理由

1. **平衡复杂度与体验**：比同步方案体验好，比WebSocket方案简单
2. **易于扩展**：后续可升级到WebSocket
3. **兼容性好**：不依赖特殊协议

### 3.2 技术栈

**后端**：
- FastAPI（异步框架）
- Celery + Redis（可选，用于任务队列）
- 或使用FastAPI后台任务（简单场景）

**前端**：
- HTML + JavaScript（纯原生，无依赖）
- 或Vue.js（如需复杂交互）

### 3.3 API设计

#### 3.3.1 上传文件接口

```
POST /api/upload
Content-Type: multipart/form-data

参数：
- dance_file: 文件
- bgm_file: 文件
- version: 可选，'modular' | 'v2' | 'parallel'（默认parallel）

返回：
{
  "task_id": "uuid",
  "status": "uploaded",
  "message": "文件上传成功"
}
```

#### 3.3.2 查询任务状态接口

```
GET /api/task/{task_id}

返回：
{
  "task_id": "uuid",
  "status": "processing" | "completed" | "failed",
  "progress": 50,  // 0-100
  "message": "正在处理...",
  "result_url": null | "下载链接",
  "error": null | "错误信息"
}
```

#### 3.3.3 下载结果接口

```
GET /api/download/{task_id}

返回：视频文件（二进制流）
```

### 3.4 前端页面设计

#### 3.4.1 布局（极简主义）

```
┌─────────────────────────────────────┐
│         BeatSync 视频对齐工具        │
├─────────────────────────────────────┤
│                                     │
│  [上传原始视频]  dance.mp4 ✓        │
│                                     │
│  [上传音源视频]  bgm.mp4 ✓          │
│                                     │
│  [开始处理]                          │
│                                     │
│  处理进度: ████████░░ 80%          │
│  状态: 正在处理...                  │
│                                     │
│  [下载结果] (处理完成后显示)        │
│                                     │
└─────────────────────────────────────┘
```

#### 3.4.2 交互流程

1. **上传阶段**：
   - 两个上传区域，分别显示"原始视频"和"音源视频"
   - 上传成功后显示文件名和大小
   - 两个文件都上传后，"开始处理"按钮才可点击

2. **处理阶段**：
   - 点击"开始处理"后，按钮禁用
   - 显示进度条和状态信息
   - 每2秒轮询一次任务状态
   - 显示预计剩余时间（可选）

3. **完成阶段**：
   - 显示"处理完成"
   - 自动显示"下载结果"按钮
   - 点击后下载视频文件

#### 3.4.3 错误处理

- 文件格式错误：上传时即提示
- 处理失败：显示错误信息，允许重新上传
- 网络错误：提示重试

## 四、实现步骤

### 阶段1：最小可用版本（MVP）

1. **后端**：
   - FastAPI基础框架
   - 文件上传接口
   - 同步处理接口（先做简单版本）
   - 错误处理

2. **前端**：
   - 基础HTML页面
   - 文件上传功能
   - 处理按钮
   - 结果下载

### 阶段2：异步处理

1. **后端**：
   - 改为异步处理
   - 任务状态查询接口
   - 任务存储（内存或Redis）

2. **前端**：
   - 添加进度显示
   - 轮询任务状态
   - 优化用户体验

### 阶段3：优化和扩展

1. 添加处理历史
2. 支持大文件分块上传
3. 添加用户认证（如需要）
4. 性能优化

## 五、需要你确认的问题

1. **处理方式**：
   - [ ] 同步处理（简单但可能超时）
   - [ ] 异步处理 + 轮询（推荐）
   - [ ] 异步处理 + WebSocket（最佳体验但复杂）

2. **版本选择**：
   - [ ] 默认使用并行处理器（两个版本都生成）
   - [ ] 让用户选择版本（modular/V2/并行）
   - [ ] 只使用一个版本（哪个？）

3. **文件限制**：
   - 最大文件大小：？MB
   - 支持的文件格式：MP4, MOV, AVI等？

4. **UI设计**：
   - [ ] 我提供设计稿
   - [ ] 你用文字描述，我来评估

5. **部署方式**：
   - [ ] 本地测试
   - [ ] 云服务器部署
   - [ ] 容器化部署（Docker）

---

**请确认以上问题，我再开始具体开发。**

